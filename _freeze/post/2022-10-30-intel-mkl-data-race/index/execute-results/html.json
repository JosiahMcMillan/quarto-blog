{
  "hash": "04c748e5ebdf8b0264dcad07a5066f22",
  "result": {
    "markdown": "---\ntitle: \"avoiding data races with intel mkl\"\nsubtitle: |\n  set the `MKL_THREADING_LAYER` environment variable to `GNU`\ndate: \"2022-10-30\"\ncategories: [notes to self, data race, intel mkl]\n---\n\n\nIf you are using Intel MKL for your BLAS/LAPACK implementation on Linux, you can set the environment variable `MKL_THREADING_LAYER` to `GNU` to avoid data races during matrix multiplication^[None of the information in this blog post is new, nor do I claim to have a good understanding. I am simply collecting some information to help my future self when this issue next rears its head.].\n\n## Background\n\nIf you do numerically intensive computing, you might want to make it faster. One way to do this is to switch out the backend implementation of linear algebra routines on your computer. At a low level, most linear algebra on your computers happens by making calls via BLAS/LAPACK APIs, and there are several libraries that offer differing implementations of the underlying methods. Some of these libraries are faster than others; many are faster than the default implementation.\n\nI use Intel MKL. On Ubuntu, you can install Intel MKL via the shell with:\n\n``` sh\nsudo apt install intel-mkl\n```\n\nYou can check your current BLAS/LAPACK implementation in `R` using `utils::sessionInfo()`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsi <- utils::sessionInfo()\nsi$LAPACK\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"/usr/lib/x86_64-linux-gnu/libmkl_rt.so\"\n```\n:::\n:::\n\n\n## The problem\n\nOn computers with multiple cores, Intel MKL can induce data races during (sufficiently large) matrix multiplies, depending on the threading model. Using the default threading model, I can reliably induce these data races like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this function should return 249.7852\ncan_induce_data_race <- function() {\n  X <- matrix(1:500 / 500, 50, 10)\n  Y <- matrix(1:1000 / 1000, 10, 100)\n\n  norm(X %*% Y)\n}\n\ncan_induce_data_race()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 249.7852\n```\n:::\n\n```{.r .cell-code}\ncan_induce_data_race()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 249.7852\n```\n:::\n\n```{.r .cell-code}\ncan_induce_data_race()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 249.7852\n```\n:::\n:::\n\n\nSee discussion [here](https://github.com/eddelbuettel/mkl4deb/issues/2), [here](https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=921193#12) and [here](https://github.com/eddelbuettel/mkl4deb/issues/9) if you're curious about underlying causes.\n\n## The solution\n\nTo avoid this problem, set the environmental variable `MKL_THREADING_LAYER=GNU`. You can check the current value of the `MKL_THREADING_LAYER` environmental variable via\n\n\n::: {.cell}\n\n```{.r .cell-code}\nSys.getenv(\"MKL_THREADING_LAYER\")\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"GNU\"\n```\n:::\n:::\n\n\nWhen `MKL_THREADING_LAYER` is not set, it defaults to `INTEL`. To set `MKL_THREADING_LAYER=GNU` universally, you can update `/etc/environment`.\n\n``` sh\necho \"MKL_THREADING_LAYER=GNU\" >> /etc/environment\n```\n\nAlternatively, tell MKL to operate without parallelism by setting `MKL_NUM_THREADS=1`. Note that you will need to restart `R` for these changes to take effect. More generally, [environmental variables are typically read once, at program startup](https://stackoverflow.com/a/74212620/5563099), so you cannot use `Sys.setenv()` to set `MKL_THREADING_LAYER` at runtime. Similarly, you cannot change the number of threads MKL uses are runtime via environmental variables (see [documentation](https://www.intel.com/content/www/us/en/develop/documentation/onemkl-linux-developer-guide/top/managing-performance-and-memory/improving-performance-with-threading/changing-the-number-of-openmp-threads-at-run-time.html)).\n\nIf you want to test the effect of different environmental variables without leaving `R`, you can use `callr::r()`, as below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncallr::r(can_induce_data_race, env = c(MKL_THREADING_LAYER = \"INTEL\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2823.996\n```\n:::\n\n```{.r .cell-code}\ncallr::r(can_induce_data_race, env = c(MKL_THREADING_LAYER = \"GNU\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 249.7852\n```\n:::\n:::\n\n\nIf you would like to change set environmental variables locally (for example, if you want `targets` to manage parallelism across tasks, while running each individual task sequentially), use an `.Renviron` at the top level of your R project. You can do this via:\n\n``` r\nusethis::edit_r_environ(scope = \"project\")\n```\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}